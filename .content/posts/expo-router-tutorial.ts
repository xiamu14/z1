export default {
  "filePath": "/Users/ben/Documents/workspace/project/z1/posts/expo-router-tutorial.md",
  "content": "<h2>expo-router 概念</h2>\n<p>在 项目目录 app 下的文件都与路由有关，<code>_layout.tsx</code> 、 <code>index.tsx</code> , 和<code>(tabs)</code>等</p>\n<h3>app/_layout.tsx</h3>\n<p>全局布局文件</p>\n<h3>app/index.tsx</h3>\n<p><strong>应用首先渲染的页面</strong>，也可以是位于 <code>app/(tabs)/index.tsx</code>。</p>\n<h3>app/(tabs)/xxx.tsx</h3>\n<p>底部导航栏路由目录，可以使用 <code>app/(tabs)/_layout.tsx</code> 对底部导航栏做定制，修改 icons，name 等。</p>\n<h2>路由堆栈</h2>\n<h3>前进</h3>\n<p>router.navigate, router.push, router.replace</p>\n<h3>后退</h3>\n<p>router.back, router.dismissTo</p>\n<h3>退出拦截</h3>\n<p>navigation.addEventListener('beforeRemove',()=>{})</p>\n<h2>路由参数</h2>\n<h3>上下文</h3>\n<ol>\n<li>通过 tabs 里的 active 判断当前激活的 Tab 页面</li>\n</ol>\n<h3>类型声明</h3>\n<pre class=\"shiki shiki-themes min-light min-dark\" style=\"background-color:#ffffff;--shiki-dark-bg:#1f1f1f;color:#24292eff;--shiki-dark:#b392f0\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color:#1976D2;--shiki-dark:#79B8FF\">router</span><span style=\"color:#6F42C1;--shiki-dark:#B392F0\">.push</span><span style=\"color:#24292EFF;--shiki-dark:#B392F0\">&#x3C;</span><span style=\"color:#6F42C1;--shiki-dark:#B392F0\">UserRouteParams</span><span style=\"color:#24292EFF;--shiki-dark:#B392F0\">>(</span><span style=\"color:#22863A;--shiki-dark:#FFAB70\">'/user'</span><span style=\"color:#212121;--shiki-dark:#BBBBBB\">,</span><span style=\"color:#24292EFF;--shiki-dark:#B392F0\"> {});</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#D32F2F;--shiki-dark:#F97583\">const</span><span style=\"color:#1976D2;--shiki-dark:#79B8FF\"> routeParams</span><span style=\"color:#D32F2F;--shiki-dark:#F97583\"> =</span><span style=\"color:#6F42C1;--shiki-dark:#B392F0\"> useLocalParams</span><span style=\"color:#24292EFF;--shiki-dark:#B392F0\">&#x3C;</span><span style=\"color:#6F42C1;--shiki-dark:#B392F0\">UserRouteParams</span><span style=\"color:#24292EFF;--shiki-dark:#B392F0\">>();</span></span></code></pre>\n<h2>思考</h2>\n<p>思考 路由跳转时传递上下文（Context）而不是 query/params，特别是 大对象、复杂状态甚至临时数据，既要避免 URL 参数污染，又要避免无限制使用全局状态。</p>\n<h3>问题背景</h3>\n<ul>\n<li>传统路由参数</li>\n<li>通常是字符串、数字、ID，适合小数据。</li>\n<li>但大 JSON / File 对象 / Skia snapshot 等数据没法直接塞到 URL。</li>\n<li>全局状态（Redux / Zustand / Valtio / Context）</li>\n<li>可以存数据，但问题是：</li>\n<li>数据和路由解耦，容易造成“僵尸状态”或内存泄露（页面关掉了，但数据还留着）。</li>\n<li>很多状态只是「跳转时的临时上下文」，没必要长期存在。</li>\n</ul>\n<p>所以需要一个 介于 params 和全局 store 之间的传递层。</p>\n<h3>方案思路：基于“导航上下文（Navigation Context）”</h3>\n<p>核心思想：</p>\n<ul>\n<li>路由跳转时，生成一个 <strong>上下文 ID</strong>（比如 uuid）。</li>\n<li>把 <strong>大对象存放在一个上下文池（Map/WeakMap）</strong> 中。</li>\n<li>跳转时只传递这个 ID。</li>\n<li>目标页面通过 ID 拿到上下文数据。</li>\n<li>页面销毁时清理对应上下文，避免内存泄漏。</li>\n</ul>\n<p>现有实现方案:</p>\n<ul>\n<li>React Router v6 的 location.state：能传 JS 对象，但不适合 RN。</li>\n<li>React Navigation 的 navigation.navigate(\"screen\", { state })：也能传对象，但在 Android/iOS 大对象传递上不可靠（可能序列化失败）。</li>\n</ul>\n<h3>实现注意</h3>\n<ul>\n<li>避免全局状态污染（上下文自动清理）。</li>\n<li>路由参数只存 轻量 ID，避免 query 过长。</li>\n<li>数据不是可序列化的（刷新或重启 App 就丢了）。</li>\n<li>多端共享时无法用 URL 直接还原（适合纯 App 内部跳转）。</li>\n<li>需要小心清理机制，否则会内存泄漏。</li>\n<li>可以实现一个 LRU Cache，存储最近的上下文，避免内存无限增长。</li>\n<li>可以在 debug 环境下打印当前上下文池，方便排查泄漏。</li>\n</ul>",
  "fileName": "expo-router-tutorial",
  "subject": [],
  "md5": "jGeUlE",
  "frontMatter": {
    "title": "expo-router 实践",
    "description": "学习 expo-router, 基于文件构建应用的路由",
    "cover": "https://images.unsplash.com/photo-1667372335936-3dc4ff716017?q=80&w=2232&auto=format&fit=crop&ixlib=rb-4.1.0&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D"
  },
  "updateAt": 1755865449369
}